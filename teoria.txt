!!! NODE JS !!!.- Node no es un lenguaje de programación, framework etc, es literalmente un entorno de ejecución de JS sin ser un navegador, es decir, sencillamente un sitio donde podemos ejecutar JS un lugar donde podemos ejecutar js sin ningun problema, esto significa que podemos crear un montón de diff tipos de apps con js en backend, terminales y dispositivos.

Es de código abierto, es multiplataforma mascOS, windows etc, es asíncrono, in put de datos, su arquitectura está orientada a eventos.

El secreto de node es que usa motor V8, es el motor de JS que utiliza el navegador chrome, chrome ejecuta js mucho más rápido, node apreovecha ese motor para ejecutar JS.

¿Que significa que sea orientado eventos?.- Es un modelo de programación que basicamente tiene un bucle que va manejando las solicitudes que le van llegando cada vez que tiene un evento, en lugar de esperar bloqueos, el va ejecutando tareas mientras espera respuestas d otras tareas que ha dejado por ahí, pero esto lo maneja en un solo thred, es decir, nodeJS es monohilo , pero tiene un sistema que hace es que livera ese proceso para poder hacer cosas en asíncrono, osea nodeJS aprovecha la sincronía y espera eventos lo que hace es simular que hace más de una cosa a la vez pero no lo hace solo hace una cosa a la vez, lo que pasa es que gracias a estar basado en eventos, va esperando que ocurra cosas, para decir voy a aparcare aquí y voy ha seguir con esto pero cuando llegue lo que deje ahí retorno con eso.

¿Porque aprenderlo?.- 
- Demanda del mercado. Linkedin, GoDaddy, Netflix, Paypal, Uber etc etc muchas empresas o casi todas usa node. Un montón de cosas usan nodeJS.

- Se puede usar todos los concocimientos de JS en node orientado al backend.
- Podemos crear app webs, apis, servicios son complejidades, scrapping, utilidades, no se limita en nada.
- Comunidad inmensa y un ecosistema todavía más grande.
- NodeJS es rápido, escalable y muy fácil de desplegar.

!INSTALACIÓN y ADMINISTRACIÓN DE VERSIONES!.-
- Podemos hacerl manual, es la pagina oficial de node podemos nosotros descaragar el instalador dependiendo el SO que tengamos. Es la más sencilla, pero la desventaja es que esta te instalará una sola versión de node, y si queremos usar una versión de node distinta en otros projectos no podremos usarla.

- Las más recomendado es usar un administrador de verison de node (NVM el más conocido), nos permite tener e instalar más de una versión y cambiar la versión a la vez.


- Tenemos otro buen administrador fnm pero este debemos de tener instalado RUST.
    - instalamos rust => curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
    - instalamos fnm => 
  Al tener instalado todo tenemos acceso a los comandos que nos ofrece por terminal ejm:
  - fnm list => nos muestra una lista de todas las versiones de node que tenemos en nuestro sistema y nos muestra la que tenemos por default.

  - fnm install node_version (18.17.0) => aqui instalamos node con la version que nosotros queremos.
  - fnm use node_version => Con este le decimos que version de node queremos que use en ese momento, sea en un proyecto o en nuestra computadora.

  - fnm alias node_version default => en cambio con este comando le decimos que por defecto use esa version de node. Siempre será esa version que use.

  - node -v => con esto vemos la versión de node que estamos usando actualemnte(x seguridad verificamos).

Node nos provee un repl (read eval print loop), ed decir podemos nosotros escrbir JS como en la consola de chrome pero en la terminal, lo que hace es leer, evaluar, imprimir lo que nosotros de decimos por la terminal en un loop osea va a estar constantemente haciendo eso como lo logramos lanznado en nuestra terminal node.

your terminal => node
Este nos abrira un repl en la terminal y podemos escirbir lo que deseemos JS obviamente.
const a = 'Hola mundo' (enter)
console.log(a)

El canal de output de node es la terminal, sería la forma de comunicarnos.
En nodeJS no tenemos el objeto window, es un método del navegador, el objeto window global no existe en nodeJS, por suerte una cosa interesante que ahora es nueva en JS, tenemos un objeto global para todos los entornos globalThis es la variale global tanto del servidor como el cliente.

!globalThis!.- Es una variable global en toda nuestra app, podemos acceder a ella no importa donde estemos siempre tendremos acceso a esta variable. En el navegador globalThis apunta a window por eso es que en el navegador window es el objeto gloabl, y en node globalThis apunta a global variable global de node, como buena práctica usaremos globalThis en node.

Podemos usar en node el console.log(), porque sale del globalThis, osea todo lo que nosotros tenemos en global es lo que podemos usar, console.log es una variable del globalThis, como Promise, fetch etc etc. Muchas de las cosas que salen de la nada salen de la variable globalThis todo.

En nodeJS nunca vamos a tener todo en un mismo fichero, lo que vamos a querer e intentar es separar en diff ficheros, para ellos vamos a usar un patron de diseño Modulo.
Este patrón en el vamos a hacer es separar nuestro código en diff ficheros y los vamos a poder importar y exportar para que ese código se reutilice así organizaremos nuestro código mejor y evitaremos repetirlo.

El sistema clasico de modulos de nodeJS es CommonJS, forma clasica y antigua.
// sum.js
function sum(a, b) {
  return a + b
}

module.exports = sum => forma no nombrada puede importarse con cualquier nombre.
module.exports = {
    sum forma nombrada con esto obligamos que donde importamos la función sea exactamente con el mismo nombre que tiene la función.
}

// importación
const sum = require('./sum') => cuando exportamos no nombrado.
const { sum } = require('./sum') => cuando exportamos nombrado.

LA extension de los archivos en node puede variar en algunas ocaciones ejm 
file.js => .js utiliza CommonJS por defecto.
file.mjs => .mjs utiliza ES modules
file.cjs => forzado a usar CommonJS

Nonde a evolcionado y por suerte teemos otra forma de importar y exportar modulos, que es en base a ES modules ejm 

// export 
export function sum(a, b) {
  return a + b
}

// import 
import { sum } from './sum.mjs'
Esta es la forma moderna y más recomendaba en la especificacion official de js, aparte de tener las vetajas de ser moderna.

! MODULO NATIVOS !.- NodeJS no trata solo de crear funciones importarlas y exportarlas, nodeJS al ser un entorno de ejecución es que nos da una biblioteca enorme de modulos nativos que nos da acceso al sistema de archivos, SO, intenet, lo podemos hacer aquí.

Modulos nativos
- os.- En versiones anteriores de node teniamos que requerir de esta forma los modulos nativos, desde la versión 16 de node ya nos es recomendable usar el nombre del módulo directo, si no ahora colocarle el prefijo node:name_module

const os = require('node:os')

En ES modules las extensiones son necearias, siempre aunque con webpack y otros empaquetadores de clente hacen que no sea necesario la extension, la especificación de ES module es obligatorio usar las extensiones, en CommonJS no es necesario porque como webpack ya lo quita por nosotros.

La lectura y escrita node no hace en el proceso principal en el hilo principal lo saca fuera.

!PATH!.- Nos permite saber el path de los archivos que tenemos, con el path podemos construir nuevas rutas de archivos, saber si un archivo tiene una extension, recuperar una extension crear rutas absolutas, podemos unir rutas también.
Es una mala práctica crear rutas a mano en node siempre por el Sistema Operativo porque, porque las barras son diff en los sistemas operarivos, lo más recomendado es usar e path ejm
Unix es asi /
windows es asi \
con este comando podemos ver la separacion de las rutas en el SO, osea las barras
console.log(path.step)
Un error muy común en nodeJS es olvidarnos de los SO que podemos llegar a usar.

! PROCESS!.-El objeto process, este process es muy importante en node es un objeto global que proporcia la información y control sobre le proceso actual de ejecución, tiene propiedades y métodos que nos permite interactuar con el entorno de ejecución de nodeJS y nos da información relacionada con el proceso actual, como x ejm los argumentos de entrada a la hora de ejecutar nuestro proceso ejm console.log(process.argv)

Esto sería los argumentos que va a recibir en la linea de comandos por ejm 
node index.js argumento1 argumento2 etc
Nos devuelve un array con lo sig:
1) Binario recibido, es decir todo el path absoluto
2) archivo ruta con nombre del archivo.
3) Todos los argumentos que le pasamos en a terminal.

!NPM!.- es un administrador de paquetes de node, salió un poco despúes de node, es el registro de paquetes más grande de código que existe, no hay ningún tipo de sistema de ningún otro lenguaje de programación o entorno de ejecución más grande que el de nodeJS, es un registro paquetes de código abierto que cualuiera puede usar de forma gratuita como React x ejm, npm es un registro público, pero npm también es una línea de comandos como npm --version.
Osea podemos usar yarn o pnpm con todos los paquetes que tiene npm.

Para iniciar un proyecto con node debemos de usar el sig comando:
  - npm || pnpm || yarn init -y.- Esto nos crea un package.json que sería un desxripción en JSON de nuestro proyecto, como título, autor, version scripts etc.

Podemos usar una dependencia una dependencia picocolors para dar un poco de vida a nuestra terminal => pnpm add picocolors


// semantic versioning 2.1.0

2 => Major cuando se rompe la compatibilidad hacia atrás.
1 => Minor cuando añaden nuevas funcionalidades.
0 => Patch cuando arreglan solo fixes.
Debemos de tener en cuenta que cada vez que instalamos una dependencia, las dependecia que estamos instalando puede ser que tiene mas dependencias etc etc.

En node tenemos dos tipos de dependecias:
- Production.- Son dependencias que nuetsro proyecto necesita para funcionar.
- Desarrollos.- Son importantes pero son solo de desarrolo, como linters, ts, webpack por ejm, que nos sirven para desarrollar usa siempre un -D es el comando npm i name_pack -D.



Los archivos .env no hacen parte de node, son de las bibliotecas que nos ayudan con node, node lo que hace es leer las variables ese es el trabajo de node.

