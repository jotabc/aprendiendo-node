!!! NODE JS !!!.- Node no es un lenguaje de programación, framework etc, es literalmente un entorno de ejecución de JS sin ser un navegador, es decir, sencillamente un sitio donde podemos ejecutar JS un lugar donde podemos ejecutar js sin ningun problema, esto significa que podemos crear un montón de diff tipos de apps con js en backend, terminales y dispositivos.

Es de código abierto, es multiplataforma mascOS, windows etc, es asíncrono, in put de datos, su arquitectura está orientada a eventos.

El secreto de node es que usa motor V8, es el motor de JS que utiliza el navegador chrome, chrome ejecuta js mucho más rápido, node apreovecha ese motor para ejecutar JS.

¿Que significa que sea orientado eventos?.- Es un modelo de programación que basicamente tiene un bucle que va manejando las solicitudes que le van llegando cada vez que tiene un evento, en lugar de esperar bloqueos, el va ejecutando tareas mientras espera respuestas d otras tareas que ha dejado por ahí, pero esto lo maneja en un solo thred, es decir, nodeJS es monohilo , pero tiene un sistema que hace es que livera ese proceso para poder hacer cosas en asíncrono, osea nodeJS aprovecha la sincronía y espera eventos lo que hace es simular que hace más de una cosa a la vez pero no lo hace solo hace una cosa a la vez, lo que pasa es que gracias a estar basado en eventos, va esperando que ocurra cosas, para decir voy a aparcare aquí y voy ha seguir con esto pero cuando llegue lo que deje ahí retorno con eso.

¿Porque aprenderlo?.- 
- Demanda del mercado. Linkedin, GoDaddy, Netflix, Paypal, Uber etc etc muchas empresas o casi todas usa node. Un montón de cosas usan nodeJS.

- Se puede usar todos los concocimientos de JS en node orientado al backend.
- Podemos crear app webs, apis, servicios son complejidades, scrapping, utilidades, no se limita en nada.
- Comunidad inmensa y un ecosistema todavía más grande.
- NodeJS es rápido, escalable y muy fácil de desplegar.

!INSTALACIÓN y ADMINISTRACIÓN DE VERSIONES!.-
- Podemos hacerl manual, es la pagina oficial de node podemos nosotros descaragar el instalador dependiendo el SO que tengamos. Es la más sencilla, pero la desventaja es que esta te instalará una sola versión de node, y si queremos usar una versión de node distinta en otros projectos no podremos usarla.

- Las más recomendado es usar un administrador de verison de node (NVM el más conocido), nos permite tener e instalar más de una versión y cambiar la versión a la vez.


- Tenemos otro buen administrador fnm pero este debemos de tener instalado RUST.
    - instalamos rust => curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
    - instalamos fnm => 
  Al tener instalado todo tenemos acceso a los comandos que nos ofrece por terminal ejm:
  - fnm list => nos muestra una lista de todas las versiones de node que tenemos en nuestro sistema y nos muestra la que tenemos por default.

  - fnm install node_version (18.17.0) => aqui instalamos node con la version que nosotros queremos.
  - fnm use node_version => Con este le decimos que version de node queremos que use en ese momento, sea en un proyecto o en nuestra computadora.

  - fnm alias node_version default => en cambio con este comando le decimos que por defecto use esa version de node. Siempre será esa version que use.

  - node -v => con esto vemos la versión de node que estamos usando actualemnte(x seguridad verificamos).

Node nos provee un repl (read eval print loop), ed decir podemos nosotros escrbir JS como en la consola de chrome pero en la terminal, lo que hace es leer, evaluar, imprimir lo que nosotros de decimos por la terminal en un loop osea va a estar constantemente haciendo eso como lo logramos lanznado en nuestra terminal node.

your terminal => node
Este nos abrira un repl en la terminal y podemos escirbir lo que deseemos JS obviamente.
const a = 'Hola mundo' (enter)
console.log(a)

El canal de output de node es la terminal, sería la forma de comunicarnos.
En nodeJS no tenemos el objeto window, es un método del navegador, el objeto window global no existe en nodeJS, por suerte una cosa interesante que ahora es nueva en JS, tenemos un objeto global para todos los entornos globalThis es la variale global tanto del servidor como el cliente.

!globalThis!.- Es una variable global en toda nuestra app, podemos acceder a ella no importa donde estemos siempre tendremos acceso a esta variable. En el navegador globalThis apunta a window por eso es que en el navegador window es el objeto gloabl, y en node globalThis apunta a global variable global de node, como buena práctica usaremos globalThis en node.

Podemos usar en node el console.log(), porque sale del globalThis, osea todo lo que nosotros tenemos en global es lo que podemos usar, console.log es una variable del globalThis, como Promise, fetch etc etc. Muchas de las cosas que salen de la nada salen de la variable globalThis todo.

En nodeJS nunca vamos a tener todo en un mismo fichero, lo que vamos a querer e intentar es separar en diff ficheros, para ellos vamos a usar un patron de diseño Modulo.
Este patrón en el vamos a hacer es separar nuestro código en diff ficheros y los vamos a poder importar y exportar para que ese código se reutilice así organizaremos nuestro código mejor y evitaremos repetirlo.

El sistema clasico de modulos de nodeJS es CommonJS, forma clasica y antigua.
// sum.js
function sum(a, b) {
  return a + b
}

module.exports = sum => forma no nombrada puede importarse con cualquier nombre.
module.exports = {
    sum forma nombrada con esto obligamos que donde importamos la función sea exactamente con el mismo nombre que tiene la función.
}

// importación
const sum = require('./sum') => cuando exportamos no nombrado.
const { sum } = require('./sum') => cuando exportamos nombrado.

LA extension de los archivos en node puede variar en algunas ocaciones ejm 
file.js => .js utiliza CommonJS por defecto.
file.mjs => .mjs utiliza ES modules
file.cjs => forzado a usar CommonJS

Nonde a evolcionado y por suerte teemos otra forma de importar y exportar modulos, que es en base a ES modules ejm 

// export 
export function sum(a, b) {
  return a + b
}

// import 
import { sum } from './sum.mjs'
Esta es la forma moderna y más recomendaba en la especificacion official de js, aparte de tener las vetajas de ser moderna.

! MODULO NATIVOS !.- NodeJS no trata solo de crear funciones importarlas y exportarlas, nodeJS al ser un entorno de ejecución es que nos da una biblioteca enorme de modulos nativos que nos da acceso al sistema de archivos, SO, intenet, lo podemos hacer aquí.

Modulos nativos
- os.- En versiones anteriores de node teniamos que requerir de esta forma los modulos nativos, desde la versión 16 de node ya nos es recomendable usar el nombre del módulo directo, si no ahora colocarle el prefijo node:name_module

const os = require('node:os')

En ES modules las extensiones son necearias, siempre aunque con webpack y otros empaquetadores de clente hacen que no sea necesario la extension, la especificación de ES module es obligatorio usar las extensiones, en CommonJS no es necesario porque como webpack ya lo quita por nosotros.

La lectura y escrita node no hace en el proceso principal en el hilo principal lo saca fuera.

!PATH!.- Nos permite saber el path de los archivos que tenemos, con el path podemos construir nuevas rutas de archivos, saber si un archivo tiene una extension, recuperar una extension crear rutas absolutas, podemos unir rutas también.
Es una mala práctica crear rutas a mano en node siempre por el Sistema Operativo porque, porque las barras son diff en los sistemas operarivos, lo más recomendado es usar e path ejm
Unix es asi /
windows es asi \
con este comando podemos ver la separacion de las rutas en el SO, osea las barras
console.log(path.step)
Un error muy común en nodeJS es olvidarnos de los SO que podemos llegar a usar.

! PROCESS!.-El objeto process, este process es muy importante en node es un objeto global que proporcia la información y control sobre le proceso actual de ejecución, tiene propiedades y métodos que nos permite interactuar con el entorno de ejecución de nodeJS y nos da información relacionada con el proceso actual, como x ejm los argumentos de entrada a la hora de ejecutar nuestro proceso ejm console.log(process.argv)

Esto sería los argumentos que va a recibir en la linea de comandos por ejm 
node index.js argumento1 argumento2 etc
Nos devuelve un array con lo sig:
1) Binario recibido, es decir todo el path absoluto
2) archivo ruta con nombre del archivo.
3) Todos los argumentos que le pasamos en a terminal.

!NPM!.- es un administrador de paquetes de node, salió un poco despúes de node, es el registro de paquetes más grande de código que existe, no hay ningún tipo de sistema de ningún otro lenguaje de programación o entorno de ejecución más grande que el de nodeJS, es un registro paquetes de código abierto que cualuiera puede usar de forma gratuita como React x ejm, npm es un registro público, pero npm también es una línea de comandos como npm --version.
Osea podemos usar yarn o pnpm con todos los paquetes que tiene npm.

Para iniciar un proyecto con node debemos de usar el sig comando:
  - npm || pnpm || yarn init -y.- Esto nos crea un package.json que sería un desxripción en JSON de nuestro proyecto, como título, autor, version scripts etc.

Podemos usar una dependencia una dependencia picocolors para dar un poco de vida a nuestra terminal => pnpm add picocolors


// semantic versioning 2.1.0

2 => Major cuando se rompe la compatibilidad hacia atrás.
1 => Minor cuando añaden nuevas funcionalidades.
0 => Patch cuando arreglan solo fixes.
Debemos de tener en cuenta que cada vez que instalamos una dependencia, las dependecia que estamos instalando puede ser que tiene mas dependencias etc etc.

En node tenemos dos tipos de dependecias:
- Production.- Son dependencias que nuetsro proyecto necesita para funcionar.
- Desarrollos.- Son importantes pero son solo de desarrolo, como linters, ts, webpack por ejm, que nos sirven para desarrollar usa siempre un -D es el comando npm i name_pack -D.



Los archivos .env no hacen parte de node, son de las bibliotecas que nos ayudan con node, node lo que hace es leer las variables ese es el trabajo de node.

Un callback son funciones que se ejecutan después de que pase algo. Normalmente cuando son cosas asincronas.
En node cuando hacemos una petición hace siempre 2, es porque estamos haciendo una petición desde el navegador, primero hace la petición que le estamos pasando y la 2da es porque intenta sacar el favicon.
Pero cuando hacemos peticiones a una api esta no hace doble petición porque le navegador no la necesita.

! SERVIDORES !.- (req, res) => {}
  - Http.- Es un protoclo de trasnferencia de hipertexto, es el más utilizado o uno de los más utilizado en internet para transmitir información. especialmente páginas web. Las peticiones son las request.
  Cuando hamemos petiticiones nosotros tenemos lo sig:

    -url.- Tenemos la url a donde nosotros estamos haciendo la petición.

    -headers.- Son cabeceras, normalemnte es información que va pegada a la petición como para darle más contexto a la petición, es decir le mandamos más información, x ejm, envio de cookies, tokens, tipos de datos esperados.

    -method.- Que tipo de petición tenemos GET POST etc.
    -body.- Este es el cuerpo de la petición, es donde van todos los datos que queremos transmitir

  Todo esto llega a nuestro server, cuando le llega la petición, espera un momento hasta que procese toda la información, puede ir a DB x ejm, una vex que tiene lo que hace es devolver una response.

  Las respuestas traen lo sig:
    - statusCode.- El estado de que ha ido bien, regular o mal.
    - headers.- Headers de respuesta
    - body.- Donde envia la información que proceso en la petición, la información que pedimos.
  Primero le decimos el statusCode luego las cabeceras que puede tener. El statusCode está separado de las cabeceras.

  Una cabecera de respuesta tiene una cosa importante también el UserAgent, es una cabecera que se pone para decir x ejm quien es el que hizo la petición quien es el usuario, nos ayuda en el servidor a poder tratar este dato x ejm, si es un movil pues le envio ménos información o temas de analiticas. Con esto podemos ver que clientes están usando nuestro servicio.

El protoclo http siempre ha tenido problemas de seguridad de forma historica, por eso tenemos también https.
Para crear APIs lo primero que nosotros debemos de tener en cuenta es discriminar las url, osea tener diff url que respondan algo.

Podemos nosotros tener un feedback en node automatico, es decir, evitar que después de cada cambio tener que reiniciar el servidor a mano para ver reflejado los cambios para esto tenemos 2 opciones:

  - --watch.- este flag nos ayuda a que el servidor siempre este a la escucha de lo que hagamos y refleje los cambios de forma automatica ejm, aunque esta experimental en versiones de node, en la 20 creo que ya no esta experimental.
    - node --watch inde.js
    - mediante scripts de node. "dev": "- node --watch inde.js"

  - nodemon.- Mediante una librería externa llamada nodemon, funciona igual al watch ejm
    - instalacion pnpm add nodemon -D (dependencia de desarrollo)
    - "dev": "nodemon index.js"

Cuando nosotros creamos SPA, normalmente tenemos errores al cargar las rutas cuando servimos nuestro app esto se da porque

  - no tenemos servidor.- Esto es porque nosotros nos tenemos un servidor levantado que verifique a que riuta se llamo y el contenido que debe devolver.

  Al no tener un servidor detrás, por lo tanto lo que debemos hacer es servir un mismo fichero independientemente de la ruta, para solucionarlo, como no sabemos responder a las rutas cuando no tenemos servidor, normalemnte depende del hosting, pero lo que debemos de hacer es que todas la rutas vayan siempre al indice, para que cargue el sj, y sea el js el que hace el procesado de las rutas.

- STATUS CODE- tenemos:

  - 100-199 .- Respuesta informativas.
  - 200-299 .- Respuesta satisfactorias.
  - 300-399 .- Redirecciones.
  - 400-499 .- Errores de cliente. SOn errore que nosostros podemos enviar, como datos que no acepta, no tener permisos de acceso a algo.

  - 500-599.- Errores del servidor 
  statusCode completos => https://http.cat/

  Más tipicos:
   200 => ok
   301 => Moved permanently esto significa que el recurso que había aquí se ha movido y le hemos redireccionado

   400 => Bad request esto sig que la request que hemos hecho no es correcta, es decir, que la rquest esta mal formada.

   404 => Not found un recurso no encontrado osea que no existe.
   500 => Internal server error, es un error de servidor que no sabemos ni siquiera que paso del lado del servidor.

   Um buffer en node es una clase global que la utilizan para trabajar con datos binarios, ejm, si nosotros leemos un archivo o una imagen, el lee un archivo los datos binarios lo guarda en un espacio de la memoria física, este espacio temporal tiene la información de forma temporalmente para poder tratarlos.
   Los buffers son muy útiles para trabajar con archivos imagenes, criptografía, para cualquier cosa que no sean cadenas de texto, números, textos planos, o json, son esenciales a la hora de trabajar con las transiciones de datos, como se leen datos de archivos o recibirlos através de la red.

  ! CABECERAS !.-  mas usados
    res.setHeader('Content-Type', 'application/json')
    res.setHeader('Content-Type', 'text/plain; charset=utf-8')
    res.setHeader('Content-Type', 'text/html; charset=utf-8')
    res.setHeader('Content-Type', 'image/jpg')
    ...etc

  Lo importante de las cabeceras es que nosotros le decimos el tipo de codificación que tienen los datos que le estamos enviando por ejm si enviamos una imagen, nosotros en si no enviamos la imagen tal cual, si no un binario leido por node, al nosotros enviarle la cabecera justa res.setHeader('Content-Type', 'image/jpg') el navegador sabe como procesarlo. Esto es muy importantes

! TIPOS DE PETICIONES!.-
  - GET
  - POST
  - PUT
  - PATCH
  - DELETE
  - HEAD.- Es igual que el GET, pero con este le decimos que no hace falata que nos envie el body. Usado para un previo paso, es decir, que x ejm un usuario tenga permisos un token etc.

  - OPTIONS.- Describe los recursos que se pueden hacer en ese path, muchas veces es el problema que tenemos con el CORS, es lo que hace el navegador para hacer una petición a un endpoint, le dice quiero que me indiques con esta url que quiero acceder cuales son los modos que tengo permitidos de comunicación contigo, el options es que le devuelve las cabeceras de CORS.

NOTA.- let y const funcionan es por ambito de bloque y los bloques se definen entre llaves, por eso es buena práctica aunque en casos sean opcionles las llaves debemos de usar siempre para que no haya colisión de constantes o let en funciones o en este caso de routing switch.

!!! EXPRESS !!!.- Express es un framework, es el más usado, de node que nos permite crear apis, app, Nextjs usa express, webpack, tiene varios años funcionando en node. Un monton de framework lanzan cabeceras propias que indican que framework está siendo usado en express es X-Powered-By: Express aunque es recomendable quitarlo.

  - instalacion:
    - pnpm add express -e

  Ventajas de express: 
    - automaticamente el detecta los content-type, de las cabeceras, en node puro teniamos que pasarle las cabeceras dependiendo el tipo de dato que enviabamos como json, images, html etc, en express no enviamos cabeceras de conten-type porque el ya lo detecta por sí solo.Obviamente cada respuesta tiene un tipo de envio es decir si nosotros queremos que devuleva un json la endpoint pues debemos de decirle el tipo x ejm
  
  app.get('/', (req, res) => {
    res.json({ message: 'Test' }) // enviamos un json, el automaticamente hace el JSON.stringify, y coloca el content-type por nosotros.
  })

  - No es necesario estar discriminando las urls, es decir como vimos tenemos que ir construyendo la api mediante un switch donde verificamos si la url es tal, si el metodo es tal etc, con express lo que necesitamos es colocar el nombre del servidor que creamos, luego tipo de la solicitud, luego dentro de esto la url, y el process function, es decir la función que se va a ejecutar cuando se lance esa url ejm 

  // servidor
  const express = require('express')
  const app = express()

  // metodo
  app.get() => el .get sería el tipo de la petición.

  // url
  app.get('/url') => dentro de la función la url como primer parámetro

  // process function
  app.get('/url', (req, res) => {

  }) => dentro de la función la funcion a ejecutarse como 2do parámetro, que esta función es la que recibe la req y la res.

  - Una mejor forma de construir la rutas en este caso el post.

! MIDDLEWARES!.- Loa middlewares son funciones, en los middlewares podemos nosotros ahcer que pasen todas las req antes que matchee con la que le indicamos a que trate, lo que hace es que cualquier request que nosotros hacemos que pasen po ahí, procesan o hacen cualquier cosa, pueden x ejm, extraer cookies, verificar si el usuario esta logeado, extraer información de json, cualquier tipo de lógica, es algo previo al tratae la request y luego lo que hace después que se proceso el middleware lo que hace es llamar al método next para que vaya a la siguiente y continue viajando la req.
En pocas palabras un middleware es una función que se ejecuta entre la petición y la respuesta.

comunmente usado con use y va del todo arriba, osea si tenemos un archivo de api y todas vayan a products se coloca el middleware y luego el resto de rutas ejm

// middleware => podemos colocar la ruta a las cuales queremos que se ejecute el middleware solo cuando entre en esas rutas en este ejm, se ejecuta el middleware siempre y cuando entre a las todas las rutas products que existan.
Es muy importante el next porque si no colocamos pues se quedara pensando en las rutas y no devolverá la respuesta a la api que se llama muy importante.

app.use('/products/*', (req, res, next) => {
  console.log('Mi primer middleware')
  // trackear la res a la DB.
  // revisar si el usuario tiene cookies
   next() ejcutamos le método para que vaya a la sig petición.
})

// si no colocamos ruta es para todas las rutas. 
app.use((req, res, next) => {
  console.log('Mi primer middleware')
  // trackear la res a la DB.
  // revisar si el usuario tiene cookies
   next() ejcutamos le método para que vaya a la sig petición.
})

// resto de rutas 
app.get('/products', (req, res) => {
  ...rest of code
})

..rest of routes

Con los middlewares podemos gestionar cors y servir archivos estáticos.

!!! REST !!!.- (REpresentational State Tranfer)
Es una arquitectura de software, se diseño para sistemas de comunicación en redes principalmente para app web, especialmente usado para construir APIS por lo cúal nace las REST API, REST se basa en los sig principios:
  - Escalabilidad
  - Simplicidad
  - Visibilidad
  - Portabilidad
  - Fiabilidad
  - Fácil de modificar

Todas la arquitecturas de software responden a crear a base de unos principios la idea de crear algo que pueda sostenerse en el tiempo de la mejor forma posible y simplificar el desarrolo de esa piexa de software, todas las arquitecturas de software se basan en esto siempre.

LOs fundamentos de REST son los sig:
  - Resouces (recursos).- En una arquitectura REST, todo es considerado como un recurso, x ejm un usuario, una entidad completa, un libro, un blog, una coleccion también, lista de libros o usuarios, cada recurso se va a identificar con una URL.

  - VERBOS http.- Get, post, put etc, que son los utilizads para definir las operaciones que se pueden realizar con los recursos, los recursos pueden hacer operaciones, normalmente estos verbos normalmente representan las acciones básicas de un CRUD, esto permite que las apps puedan interactiar con estos recursos.

  - Representaciones.- Los recursos pueden tener muchas represntaciones, como JSON, xml, html, el cliente debería poder decidir la representación del recurso, los recursos pueden representarse en cualquier formato no debería estar atado a un en concreto, normalmente es la representación en JSON, lo importante es que de alguna forma este separada la representación del propio recurso.

  - Stateless.- Significa que cada solicitud que hagamos al servidor debe contener toda la información necesaria para entender esa solicitud, es decir, que el servidor no debe mantener ningún estado sobre el cliente entre solicitudes, es muy importante esto, el servidor no puede ni necesita hacer nada que gurade información para poder enviarle al cliente, esa informacion siempre debe de ir en la url. El cliete debe enviar toda la información necesaria para procesar la request, el servidor no necesota ningún estado para procesar la request. Nuestro backend no debe de guardar información para saber como tiene que constestar esta request.

  - Interfaz uniforme.- LA interfaz entre el servidor y el cliente sea uniforme, consistente para todas las interacciones. Basicamente que nuestras url tienen que hacer lo mismo, siempres se tiene que llamar igual.

  - Separación de conceptos.- Los componentes del cliente y el servidor estén separados entre sí, esto permite que cliente y servidor evoluvicionen de forma separada.

  Se puede crear apis que no sean rest precisamente. como x ejm GraphQL.
  
Cuando se crea un recurso de POST es una mala práctica coloar el ...req.body, es mejor obtener todos los datos de y validar lo que nos envían en la req.
LAs validaciones en node podemos manejar un herramienta muy interesante, en este caso usaremos zod
  pnpm add zod -E

Podemos validar nosotros de diff maneras, validar la req en lugar del objeto de las movies, más interesante es crear el objeto(schema) de las movies.

El error 400(Bad Request) nos indica que el cliente ha hecho algo mal y está bien porque esto quiere decir que el cliente no puede repetir esta request si no va a repetir el problema.

El error 422(Unprocesable Entity) que nos indica que el servidor a entendido la req el tipo d contendio que todo funciona bien, pero la sintaxis del recurso que se quería crear no se podía crear por una validacón o instrucción incorrecta.

Nuestras apis tienen que estar abiertas a todo le podemos pasar de todo sin que revienten y luego procesar o que necesita no podemos petar a cada rato por cada error que cometan los usuarios o le pasemos algo demás como por ejm el paso en desorden de las propiedades etc etc, pero tiene que ser exquisitas en lo que preocesan y tienen que focalizarse en lo que devuelven.
Como vemos en el sig ejm estamos intentando una inyección SQL, no nos da error porque la API recibe de todo pero procesa lo que necesita y practicamente lo ignora.
Con zod cuando esa propiedad del objeto no se pasa en el body el lo ignora completamente y no actuliza esa propiedad así la pasemos. 

{
    "sql": 'SELECT * movies',
    "title": "The Godfather",
    "year": 1975,
    "director": "Francis Ford Coppola",
    "duration": 175,
    "poster": "https://img.fruugo.com/product/4/49/14441494_max.jpg",
    "genre": [
      "Crime",
      "Drama"
    ]
}

!DIFF ENTRE POST PUT Y PATCH!
Que es la Idempotencia.- La Idempotencia es la propiedad de realizar una acción determinada varias veces y aun así conseguir siempre el mismo resultado que se obtendría al hacerlo una vez.
Esto puede funcionar o es cuando usamos las funciones puras por ejm un función que sume 2 más dos las veces que se llamen será siempre 4.

  POST                    PUT                              PATCH
- crea un nuevo         - Actualizar totalmente           - Actualizar parcialmente
  elemento/recurso        un elemento ya existente          un elemento/recurso
  en el server.           o crearlo si no existe.

- No es Idempotente     - Idempotente si, porque x más   - Idempotente, tal vés porque podemos
  porque siempre crea     veces que se llame a esta api    tener un campo updatedAt y se genera no
  un nuevo recurso        el resultado siempre será el     el mismo recurso. como puede pasar en el PUT.
                          mismo.

  /movies                   /movies/123                     /movies/123

npx servor ./web este comando lo que nos hace es servir en una URL por ejm una pagina web estarica pequeña como en nuetsro caso para 


!!! CORS !!!.- Es un mecanismo que reestringue en una página web para que un dominio sea de otro domino que quiere acceder a este recurso y ver si ese recurso lo puedes usar en un origen y es algo que hacen los naveagores. En navaegadores porque, porque siempre el navegador es el que hace las peticiones. por ejm nuestra api esta en localhost:3000 y nuestro navegador este en localhost:4000 aquí da CORS.
Esto responde casi siempre con una falta de cabecera en nuestra api, esto se da porque no existe una cabecera que le podamos nosotros decir vale si puedes. 
El error que comunmente da es "Error uso compartido de recursos entre dominios: MissingAllowOriginHeader"
El cors de arregla siempre en el backend, ya sea api, ya sea en el proxy, o el enrutador en lo que sea que pueda añadir esta cabecera si no está esa cabecera no funcionará.

Podemos inclcuso según cada endpoint dar acceso o no. ejm
app.get('/movies', (req, res) => {
  // con el * le decimos que todos los origenes son válidos
  res.header('Access-Control-Allow-Origin', '*')
  // podemos nosotros controlar el origen desde donde queremos que se pueda llamar a nuestra API.
  res.header('Access-Control-Allow-Origin', 'http://localhost:8080')
  const { genre } = req.query

  if (genre) {
    const filteredMovies = movies.filter(movie => movie.genre.some(g => g.toLowerCase() === genre.toLowerCase()))
    return res.json(filteredMovies)
  }

  return res.json(movies)
})

Pero nosotros de antemano no podemos saber que origen abrián. Podemos crear una lista de origenes aceptados por ejm como en este ejm.

const ACCEPTED_ORIGINS = [
  'http://localhost:8080', // pueden ser locales
  'https://movies.com' // como de producción.
]

app.get('/movies', (req, res) => {
  const origin = req.headers('origin')

  // este !origin podemos hacerlo cuando no tenemos la cabecera cuando son los mismos origenes.
  if (ACCEPTED_ORIGINS.includes(origin) || !origin) {
    res.header('Access-Control-Allow-Origin', '*')
  }
  const { genre } = req.query

  if (genre) {
    const filteredMovies = movies.filter(movie => movie.genre.some(g => g.toLowerCase() === genre.toLowerCase()))
    return res.json(filteredMovies)
  }

  return res.json(movies)
})

Hay un caso más que debemos de tener en cuenta que es bastante importante, que el origin esta cabecera origin no nos envía la cabecera origin, hay casos donde no nos envia nuca el header de origin cuando la petición es del mismo origen osea  'http://localhost:8080' => 'http://localhost:8080' el mismo endpoint

Como vismos podemos hacerlo para cualquier url que tengamos podemos controlar cada endpoint así, pero como vemos no funciona para todos.

El CORS es más jodido con métodos completjos, en los metodos complejos existe una cosa llamada CORS, PRE-flight, esto cuando nosotros hacemos un PUT/PATCH/DELETE, requiere una petitición especial llamada options, es una petición previa, que lo que va a hacer es pregunatr antes de hacer PUT/PATCH/DELETE cuentame, entonxes este option es el que no tiene la cabecera.
Debemos de agregar también una petición a options y pasarle esa cabecera y una extra donde le indicamos los métodos que puede permitir.

metodos normales GET/HEAD/POST
metodos complejos PUT/PATCH/DELETE

app.options('/movies/:id', () => {
  const origin = req.header('origin')

  if (ACCEPTED_ORIGINS.includes(origin)) {
    res.header('Access-Control-Allow-Origin', origin)
    res.header('Access-Control-Allow-Methods', 'GET, POST, PATCH, DELETE')
  }

  res.send()
})

También existe un middleware que los podemos colocar en nuestro punto de entrada, que lo que hace es automatizar las cabeceras automatiza lo que hicimos nosotros en los ejm aunque este middleware coloca un * y no tiene mucho sentido colocarlo así. por ejm

Instalación => pnpm add cors -E

// aqui en este ejm vemos como podemos también usar el middleware de cors con origenes definidos.
app.use(cors({
  origin: (origin, callback) => {
    const ACCEPTED_ORIGINS = [
      'http://localhost:8080', // pueden ser locales
      'https://movies.com' // como de producción.
    ]
    if (ACCEPTED_ORIGINS.includes(origin)) {
      return callback(null, true)
    }

    if (!origin) {
      return callback(null, true)
    }

    return callback(new Error('Not allowed by CORS'))
  }
}))


!!! Deploy en fl0 pasos !!!
  - Podemos hacerlo lo más fácil por medio de un repo de git, aparece al crearnos una cuenta.
  - Nos aparecera todos los projects quetenemos en git y le damos a connect, y luego seguimos los pasos.
  - Selecccionar la rama main o principal siempre, para que cuando se haga un commit a esa rama automaticamente de haga el deploy.
  - Tambien nos permite a nosotros subir una DB de postgres pero es un solo proyecto en la versino gratis.
  - Crear en nuestro proyecto node un scrip de start "start": "node index.js", por defecto es que los servicios de cloud usan para partir el proyecto.
  - Otra cosa básica y muy importante es revisar que nuestro puerto siempre este con una variable de entorno porque el servicio que estamos usando de hosting el lo coloca por defecto un puerto através de las variables de entorno.

  const PORT = process.env.PORT ?? 3000
  app.listen(PORT, () => {
    console.log('Server on port', PORT)
  })

  ! QUES ES npm ci !.- ci (clean install), es un comando parecido a npm install, este npm ci es un comando que lanza un npm install pero muchisimo más optimizado para que tarde lo minimo posible y esto es gracias al package.lock.

  Con el sistema de modulos de node commom.js las extensiones no son obligatorias, porque node internamente tiene un internamente una cosa llamada resolve que lo que hace es resolver esas extensiones, el intenta el archivo con cada extension hasta que lo encuentra, osea sin importamos ./archivos/text.json, ./archivos/text.js etc hasta que encuentra.

  En EMs no está permitido hacer esto import movies from './movies.json', no podemos importar json no hace prte de la especificación, lo que teemos que hacer es decir a node que importe esto como un json podemos arreglarlo de 3 formas:

    - import movies from './movies.json' assert { type: 'json' }, esta sintaxis con assert era experimental ahora la sintaxis es así import movies from './movies.json' with { type: 'json' } pero esta aún no lo soporta pero ese será la importación del json más adelante.
    .con el assert funciona pero se dañara despues cuando quiten esa sintaxis.

    - Segunda forma es hacerlo mediante fs.
    import fs from 'node:fs'
    const movies = JSON.parse(fs.readFileSync('./movies.json', 'utf-8'))

    - Tercera forma la más correcta en ESM, es crear un require en node, osea pordemos crear una función, el require no solo nos permite crear modulos si no tiene también información de nuestra app. Es la mejor manera porque el require de forma nativa es capaz de comerce los json además estos modulos internos ya están compilados por node y es más rápido.

    import { createRequire } from 'node:module'

    const require = createRequire(import.meta.url)
    - import.meta.url => import palabra reservada y además tiene información de los modulos y el sistema de archivos de nuetsro proyexta, meta son los metadatos de nuestro proyecto, url lo que hace es hablar de donde está el propio archivo, entonces los require es como si los hicieramos desde la raíz.

    // con esto le decimos de donde queremos que me traiga el archivo.
    const movies = require('./movies.json')


!!! ARQUITECTURA MVC !!!.- (Modelo Visita Controlador) 